# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки в языке Prolog представлены в виде бинарного дерева, в листах которого находятся элементы списка или пустой список, и они очень отличаются от того, что в императивных языках называют списком, так как такая структура данных есть не везде. Важно, что в Prolog в элементы списка можно положить любые объекты. Получается, список может состоять из двух частей: головы – Head (которая может быть пустой) и хвоста – Tail (который может сам являться списком), и также список может быть пустым. Обрабатываются в Prolog списки только рекурсивно, с разделением на голову и хвост. По сути, в Prolog списки больше похожи на массивы (это сравнение уместно, так как в программах массивы и списки используются гораздо чаще), хотя к элементам массива мы имеем произвольный доступ, когда о списках такого не скажешь. Стоит отметить, что в императивных языках возможно использование итераторов, для обращения к какому-либо элементу списка.

## Задание 1.1: Предикат обработки списка

Получение последнего элемента 
`my_last(X,E).` - предикат определяет последний элемент списка X без использования стандартных предикатов 
`my_last_std(X,E).` - предикат определяет последний элемент списка X c использованием стандартного предиката append 
Примеры использования:
```prolog
?- my_last([1,2,3],X).
X=3.
?- my_last([1,2,3],3).
true.
?- my_last([1,2,3],2).
false.
?- my_last_std([1,2,3],X).
X=3.
?- my_last_std([1,2,3],3).
true.
?- my_last_std([1,2,3],2).
false.
```

Реализация:
```prolog
%без std предикатов
my_last([E],E):-!.
my_last([_|T],E):-my_last(T,E).
% с std предикатом append
my_last_std(L,O):-append(_,[O],L).
```

В самом начале стоит остановочный предикат, который говорит, что если список состоит из одного элемента, то этот элемент и есть последний. Во второй строчке нам не важно, что хранится в голове списка, поэтому ее обозначим независимой переменной. Также говорим, что последний элемент списка - последний элемент хвоста списка.

при использовании стандартных предикатов применим предикат append, который говорит, что для списка последний элемент будет E, если мы можем путем сложения какого -то спика с этим элементом получить исходный список.


## Задание 1.2: Предикат обработки числового списка

Вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей).
`my_scalar(X,Y,R).` - предикат вычисляет скалярное произведение без использования стандартных предикатов
`my_scalar_std(X,Y,R).` - предикат вычисляет скалярное произведение с использованием стандартного предиката same_length 
Примеры использования:
```prolog
?- my_scalar([1,2,3],[3,2,1],X).
X = 10.
?- my_scalar([1,2,3],[3,2,1],10).
true.
?- my_scalar([1,2,3],[3,2,1],18).
false.
?- my_scalar_std([1,2,3],[3,2,1],X).
X = 10.
?- my_scalar_std([1,2,3],[3,2,1],10).
true.
?- my_scalar_std([1,2,3],[3,2,1],18).
false.
```

Реализация:
```prolog
%без std предикатов

%Длина списка
length_list([], 0).
length_list([_|X], N) :-length_list(X, N1), N is N1+1.

%Проверка на совпадение длин списков
%(список, список)
comp_length(L1, L2) :-length_list(L1, N), length_list(L2, C), N =:= C.

%Умножение голов списков
%(список, список)
mult_heads([], [], 0). 
mult_heads([H1|T1], [H2|T2], X) :-C is H1*H2, mult_heads(T1, T2, X1), X is X1 + C. 	

%(список, список, значение)
my_scalar(L1, L2, X) :-comp_length(L1, L2), mult_heads(L1, L2, X).
% с std предикатом same_length
%(список, список, значение)
my_scalar_std(L1, L2, X) :-same_length(L1, L2), mult_heads(L1, L2, X).
```
comp_length(L1, L2) проверяет спиcки на совпадение размерностей, используя length_list(L, N) - реализацию стандартного предиката length(L, N), mult_heads(L1, L2, Sum) умножает головы списков. Затем, рекурсивно "отбрасывая" головы, проходит по ним и складывает получившиеся произведения. Так как при рекурсивном прохождении в конце оба листа будут пустыми, то необходимо это предусмотреть, my_scalar(L1, L2, X) объединяет проверку на размерность и само скалярное произведение.

при использовании стандартных предикатов применим предикат same_length, который сравнит размеры списков, применим mult_heads для вычисления скалярного произведения

## Задание 2: Реляционное представление данных

Необходимо самому осуществить реализацию нужной структуры. В эту задачу входят: анализ отношений, описание ограничений, правил на возможные значения и комбинации значений
Главная мысль реляционной модели сводится к описанию данных, как совокупности предикатов (отношений) над конечным набором предикатных переменных. При том, что запрос информации к таким данным является предикатом, в то время как результат - множество ответов, удовлетворяющих заданной структуре программы.
К плюсам работы с реляционным представлением можно отнести простоту понимания для человека. Это способствует «разделению» программы на компоненты, проще говоря – правила, что позволяет реализовывать задачу по этим компонентам, независимым друг от друга в общем смысле, иначе возможна замена ненаписанных компонент множеством фактов. С другой стороны, для конкретной задачи могут плохо подходить предикаты-факты, что вызовет сложность правил и их громоздкость. Это и есть главный недостаток подобного подхода.
«Деление» на две части представления из four.pl позволяет определить две группы: списки студентов группы и журналы с успеваемостью по предметам.
К сожалению, обращение к фактам, которые связывают студента с его оценкой, невозможно просто так, ведь они находятся внутри списка, который, в свою очередь, находится внутри журнала по определённому предмету. Происходит это потому, что в списках хранятся термины, а не факты, что делает факты – терминами, это приводит к тому, что использование терминов возможно только при прохождении через список. Что в свою очередь приводит к «трёхслойным» и более правилам, затрудняющим понимание и поиск проблем. Но стоит отметить, что списки групп позволили легче ориентироваться в журналах успеваемости. Хотя, замена журналов на факты с предметом, студентом и оценкой облегчила бы задачу.

1.1) Для каждого студента найти средний балл

Примеры использования:
```prolog
?- average_mark('Шарпов',X).
X = 0.
?- average_mark('Шарпин',X).
X = 4.
?- average_mark('Петровский',X).
X = 3.6666666666666665.
?- average_mark('Ивановский',X).
X = 3.8333333333333335.
?- average_mark('Иванов',X).
X = 3.6666666666666665.
?- average_mark('Текстописова',X).
X = 4.666666666666667.
```
Реализация:
```prolog
studsearch([], _, 0).
studsearch([grade(X, Y)|_], Student, M) :-X == Student, !, M is Y.
studsearch([_|T], Student, N) :-studsearch(T, Student, N).
marks_for_exams(Student, X) :-subject(_, Y), studsearch(Y, Student, X).
average_mark(Student, S) :-bagof(X, marks_for_exams(Student, X), L), sum_list(L, SL), length(L, LL), S is SL / LL.
```
studsearch рекурсивно возвращает оценки студента Student исходя из заданного списка, marks_for_exams возвращает все оценки студента, average_mark возвращает оценки заданного студента по всем предметам

1.2) Для каждого студента найти сдал ли он экзамены

Примеры использования:
```prolog
?- fcheck('Шарпин',X).
X = 'Логическое программирование' ;
X = 'Математический анализ' ;
X = 'Функциональное программирование' ;
X = 'Информатика' ;
X = 'Английский язык' ;
X = 'Психология'.
?- fcheck('Шарпин','Математический анализ').
true.
?- fcheck('Ивановский','Математический анализ').
true.
?- fcheck('Иванов','Математический анализ').
true.
?- fcheck('Петров','Математический анализ').
false.
```
Реализация:
```prolog
fcheck(Student, Sub) :-subject(Sub, Y), studsearch(Y, Student, M), M > 2.
```
studsearch описанный выше позволяет найти оценку студента по предмету, если она больше 2, то студент сдал, Y- журнал оценок по предмету.
Также при помощи автоматического перебора можно посмотреть, какие предметы сдал студент.

2. Для каждого предмета найти количество несдавших студентов

Примеры использования:
```prolog
?- fail('Функциональное программирование',X).
X = 0.
?- fail('Функциональное программирование',2).
false.
?- fail('Функциональное программирование',0).
true.
?- fail('Математический анализ',0).
false.
?- fail('Математический анализ',X).
X = 1.
?- fail('Логическое программирование',X).
X = 3.
```
Реализация:
```prolog
fcount([], 0).
fcount([grade(_, Y)|T], C) :-Y < 3, !, fcount(T, N), C is N + 1.
fcount([_|T], N) :-fcount(T, N).
%(предмет, количество)
fail(Sub, X) :-subject(Sub, L), fcount(L, X).
```
fcount выводит количество несдавших студентов исходя из журнала(1. Условие для пустого списка- оценка 0; 2. проверка на оценку меньше 3; 3. рекурсивно вызываем fcount и прибавляем 1 к количеству получивших < 3), fail вызывает fcount, считает сколько студентов не сдало определенный предмет

2. Для каждой группы найти студента(ов) с максимальным средним баллом

Примеры использования:
```prolog
?- group_best(101).
Мышин
true.
?- group_best(102).
Биткоинов
true.
?- group_best(103).
Текстописова
true.
?- group_best(104).
Фулл
Джаво
Запорожцев
true.
?- group_best(105).
false.
```
Реализация:
```prolog
%средняя оценка
avg([H|_], X) :-average_mark(H, X).
avg([_|T], X) :-avg(T, X).
%определение наибольшей средней оценки
check_best([], _).	
check_best([H|T], Max) :-average_mark(H, A), A =:= Max, !, check_best(T, Max), write(H), nl.
check_best([_|T], Max) :-check_best(T, Max).
%нахождение в группе студентов с наибольшей оценкой
group_best(N) :-group(N, Y), bagof(M, avg(Y, M), L), max_list(L, Max), check_best(Y, Max).
```
avg считает среднюю оценку всех студентов используя предикат average_mark, check_best печатает студентов с максимальным средним баллом, используя логику как в studsearch, group_best объединяет средние баллы студентов определённой группы  в список (bagof(X, P, L)), ищет максимальный средний балл из этого списка с помощью стандартного предиката max_list и вызывает checkMaxсо списком-группой  и полученным максимальным баллом.

## Выводы

На начальных уровнях обучения языку Prolog помогает задание "реализация своих стандартных предикатов", которое знакомит с таким явлением, как логическое программирование, а также с использованием предикатов различными способами. Одним из больших отличий императивных языков от Prolog является логика постановки задачи. Ведь мы указываем не как что-то сделать, а что нужно сделать. Да и наличие предиката при пошаговом выполнении позволяет следить за тем, в каком порядке выполняются правила. Во время работы с Prolog осознаёшь, что для полного понимания логического программирования нужно потратить не мало времени на практику, но подобный опыт позволяет научиться с лёгкостью делить сложные задачи на более простые подзадачи, а также заставляет смотреть на задачу, как на набор целей.
